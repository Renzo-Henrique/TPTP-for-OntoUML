%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%%% Existência de mundos e entidades
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%

% Existe pelo menos um mundo
fof(ax_exists_world, axiom,(
  ?[W]: world(W)
)).

% Existe pelo menos uma entidade
fof(ax_exists_entity, axiom,(
  ?[E]: entity(E)
)).

% Entidades são diferentes de mundos
fof(ax_entity_different_than_world, axiom, (
  ![X, W]: ( exists(X, W)  => (X != W & entity(X) & world(W)))
)).

%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%%% Existência DE INSTANCIAS DAS CLASSES criadas
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%

% Existem apenas as classes especificadas
% Tudo que existe deve ser instância de sortal
% TODAS AS COISAS QUE EXISTEM SÃO INSTÂNCIAS DE ALGUM DOS TIPOS DE SORTAL DO MODELO
fof(ax_existence_of_sortal_instances, axiom, (
  ![X, W]: ( exists(X, W) => (person(X, W)) )
)).

% Todos as coisas que existem são instâncias de um dos kinds do modelo
% agrupar cada classe do tipo kind e colocar na existência das classes

% TODO:: Fazer um desse para cada sortal
% TODAS AS COISAS QUE SAO INSTANCIAS DE UM SORTAL EM ALGUM MUNDO
% CONTINUAM SENDO INSTÂNCIAS DO MESMO SORTAL EM TODOS OS MUNDOS NO QUAL EXISTAM
fof(ax_rigid_sortal_ex_classX, axiom, (
  ![X, W1]: (person(X, W1) => ( 
              (exists(X, W1) &  %% ?!?!?!? SE X FOR INSTANCIA DE UM SORTAL EM W, ENTÃO EXISTE X EM W
            ![W2]: ((exists(X, W2) & W1 != W2) => (person(X, W2))) %% TALVEZ A ORDEM INVERTIDA (DIF. DEPOIS) SEJA MAIS EFICIENTE
    )
  )
))). % Sortal permanece sortal em todos os mundos


% TODO:: Fazer um desse para cada antirígido
% TODAS AS COISAS QUE SAO INSTANCIAS DE UM TIPO-ANTI-RIGIDO EM ALGUM MUNDO
% PODEM NÃO SE-LO EM OUTRO UNDO
fof(ax_antirigid_ex_classX, axiom, (
  ![X, W1]: (child(X, W1) => (
            ?[W2]: (exists(X, W2) & W1 != W2 & (~child(X, W2))) %% TALVEZ A ORDEM INVERTIDA (DIF. DEPOIS) SEJA MAIS EFICIENTE
    )
  )
)). % Antirígido possui um mundo em que ele não é aquela instância
% não deveria ser similar ao axioma *ax_rigid_sortal_ex_classX*?

%% ALGUMA REGRA PARA CATEGORIES/MIXINS ?
%% QUALITIES / MOMENTS / RELATORS ?


%% NAO TENHO CERTEZA SE ISSO É NECESSÁRIO/CORRETO!?!? É PRA SIMULAÇÃO DE MUNDOS?
%% SE FOR, MELHOR DEIXAR NO FINAL E COM UM COMENTÁRIO EXPLICANDO
% Existe pelo menos um person(X)
fof(ax_exists_person, axiom,(
  ?[X, W]: (exists(X, W) & person(X, W))
)).

% Existe pelo menos um child(X)
fof(ax_exists_child, axiom,(
  ?[X, W]: (exists(X, W) & child(X, W))
)).

% Existe pelo menos um teenager(X)
fof(ax_exists_teenager, axiom,(
  ?[X, W]: (exists(X, W) & teenager(X, W))
)).

% Existe pelo menos um adult(X)
fof(ax_exists_adult, axiom,(
  ?[X, W]: (exists(X, W) & adult(X, W))
)).

% Existe pelo menos um universityStudent(X)
fof(ax_exists_universityStudent, axiom,(
  ?[X, W]: (exists(X, W) & universityStudent(X, W))
)).


%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%%% Inclusão das taxonomias
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%%%TODO:: Isso acaba incluindo o multinível
%fof(ax_taxonomy_of_created_class_person, axiom, (
%  ![X]: (person(X)  => kind(X))
%)).

%fof(ax_taxonomy_of_created_class_child, axiom, (
%  ![X]: (child(X)  => phase(X))
%)).

%fof(ax_taxonomy_of_created_class_teenager, axiom, (
%  ![X]: (teenager(X)  => phase(X))
%)).

%fof(ax_taxonomy_of_created_class_adult, axiom, (
%  ![X]: (adult(X)  => phase(X))
%)).

%fof(ax_taxonomy_of_created_class_universityStudent, axiom, (
%  ![X]: (universityStudent(X)  => role(X))
%)).

%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%%% Especializacao
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
fof(ax_especialization_of_created_class_child, axiom, (
  ![X, W]: (child(X, W)  => person(X, W))
)).

fof(ax_especialization_of_created_class_teenager, axiom, (
  ![X, W]: (teenager(X, W)  => person(X, W))
)).

fof(ax_especialization_of_created_class_adult, axiom, (
  ![X, W]: (adult(X, W)  => person(X, W))
)).

fof(ax_especialization_of_created_class_universityStudent, axiom, (
  ![X, W]: (universityStudent(X, W)  => person(X, W))
)).



%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%%% Genset
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%

% PhasesOfPerson é disjunto
fof(ax_generalization_set_disjoint_PhasesOfPerson, axiom, (
  ![X, W]: (~ (child(X, W) & teenager(X, W)) &
            ~ (child(X, W) & adult(X, W))    &
            ~ (teenager(X, W) & adult(X, W)) )
)).

%%% ALTERNATIVA PARA A DISJUNÇÃO
%%% MAIS LEGIVEL, MAS PODE SER MENOS EFICIENTE (EXPLOSAO COMBINATORIAL)
%%% VALE A PENA EXPLICAR A ESCOLHA NO RELATORIO
fof(ax_generalization_set_disjoint_PhasesOfPerson_alternative, axiom, (
  ![X, W]: ((child(X, W) => (~teenager(X, W) & ~adult(X, W))) & 
            (teenager(X, W) => (~child(X, W) & ~adult(X, W))) &
            (adult(X, W) => (~child(X, W) & ~teenager(X, W))) )
)).


% PhasesOfPerson é completo:
fof(ax_generalization_set_complete_PhasesOfPerson, axiom, (
  % TODO:: Para todo X, visto que é para phase? %% NÃO SE A GENTE DIZ QUE INSTANCIA DE SORTAL X, ENTAO EXISTE X, W
  ![X, W]: (person(X, W) => (child(X, W) | teenager(X, W) | adult(X, W)))
)).

%% MAKES SENSE IF UNIVERSITY STUDENT WERE IN A GENTSET
%% MAYBE ADD ANOTHER CLASS TO MAKE AN INCOMPLETE GENSET TO PROPER ILLUSTRATE
fof(ax_generalization_set_incomplete_RolesOfPerson, axiom, (
  % TODO:: Existe X, visto que é para um genset incomplete role? %% NÃO SE A GENTE DIZ QUE INSTANCIA DE SORTAL X, ENTAO EXISTE X, W
  ?[X, W]: (person(X, W) & ~( universityStudent(X, W) & universityProfessor(X,W) ) ) 
)).



%%% QUAL A FUNÇAO DESSA CONJECTURA?
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%%% Conjectura
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%fof(conj_disjoint_child_adult_teenager, conjecture, (
%  ?[X]: (teenager(X) & ~(universityStudent(X)))
  %?[X]: (teenager(X) & (universityStudent(X)))
%)).

