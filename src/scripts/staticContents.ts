// AUTO-GENERATED FILE. DO NOT EDIT.

export const baseClassAxioms = "\n% fof(ax_powerType_estereotype, axiom, (\n%     ![T]: (powerType(T) => (monadicType(T)))\n% )).\n% fof(ax_powerType_specializes, axiom, (\n%     ![T1, T2]: ((powerType(T1) & specializes(T1, T2) ) => (powerType(T2)))\n% )).\n\n% fof(ax_subkind_specializes_exactly_one_kind, axiom,\n%     ![T1]: (subkind(T1) => (![T2,T3]: (\n%                 (kind(T2) & kind(T3) & specializes(T1,T2) & specializes(T1,T3))\n%                    => T2 = T3\n%                 )\n%            )\n%     )\n% ).\n\n";

export const baseMltAxioms = "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%% Disjointness\n%\n% Axioms for reified class disjointness.\n% \n% - `disjointWith(C1, C2)` ⇔ C1 ≠ C2 ∧ no instance belongs to both in any world.\n% - Symmetric: if C1 is disjoint with C2, then C2 is disjoint with C1.\n% - Irreflexive: no class is disjoint with itself.\n%\n\n% A class C1 is disjoint with C2 iff they are different and share no instance in any world\nfof(ax_disjointWith, axiom, (\n  ![C1, C2]: (disjointWith(C1, C2) <=>\n              (monadicType(C1) & monadicType(C2)  & (C1 != C2) & ~?[X,W]: (iof(X, C1, W) & iof(X, C2, W)))\n  )\n)).\n\n% Disjointness is symmetric: if C1 is disjoint with C2, then C2 is disjoint with C1\nfof(ax_disjointWith_symmetry, axiom, (\n  ![C1, C2]: (disjointWith(C1, C2) => disjointWith(C2, C1))\n)).\n\n% No class is disjoint with itself (irreflexivity)\nfof(ax_disjointWith_irreflexivity, axiom, (\n  ![C1]: (~disjointWith(C1, C1))\n)).\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%% Overlap\n%\n% Axioms for reified class overlap.\n%\n% - `overlappingWith(C1, C2)` ⇔ ∃x,w such that x ∈ C1 and x ∈ C2 in some world w.\n% - Symmetric: if C1 overlaps C2, then C2 overlaps C1.\n% - Reflexive: every class overlaps with itself (if it is a type).\n%\n\n% Two classes overlap iff there exists an individual that is instance of both in some world\nfof(ax_overlappingWith, axiom, (\n  ![C1, C2]: (overlappingWith(C1, C2) <=>\n              ( monadicType(C1) & monadicType(C2) & ?[X,W]: (iof(X, C1, W) & iof(X, C2, W)))\n  )\n)).\n\n% Overlapping is symmetric\nfof(ax_overlapping_symmetry, axiom, (\n  ![C1, C2]: (overlappingWith(C1, C2) => overlappingWith(C2, C1))\n)).\n\n% Any class overlaps with itself (reflexivity)\nfof(ax_overlapping_reflexivity, axiom, (\n  ![C]: (monadicType(C) => overlappingWith(C, C))\n)).\n\n% Disjoint classes cannot overlap\nfof(ax_disjoint_implies_not_overlapping, axiom, (\n  ![C1, C2]: (disjointWith(C1, C2) => ~overlappingWith(C1, C2))\n)).\n\n";

export const baseNecessityOfRelationsAxioms = "%%%%%%%%%%%%%%%\n%%%%% NECESSITY OF RELATIONS\n%%%%%%%%%%%%%%%\n% fof(ax_momentType_must_have_a_relation_with_endurantType, axiom, (\n%     ![T1]: (momentType(T1) => \n%             ?[ET, R]:(T1 != ET & endurantType(ET) & (\n%                 (connectsType(T1, ET, R) | connectsType(ET, T1, R))\n%                 |\n%                 ?[T2]: (T1 != T2 & (properSpecializes(T1, T2) | properSpecializes(T2, T1)) & (connectsType(T2, ET, R) | connectsType(ET, T2, R)))\n%                 ))\n%         )\n% )).\n\n\n% Todo momentType t1 deve possuir um connectsType entre ele ou na árvore de especializações dele\n\n\n\nfof(ax_momentType_must_have_a_relation_with_endurantType, axiom, (\n    ![T1]: (momentType(T1) => \n            ?[ET, R]:(T1 != ET & endurantType(ET) & (connectsType(T1, ET, R) | connectsType(ET, T1, R))) \n    )\n)).\n\n\n%%% DESCOMENTAR\n% fof(ax_perdurantType_must_have_a_relation_with_monadicType, axiom, (\n%     ![T1]: (perdurantType(T1) => \n%         ?[T2, R]:(T1 != T2 & monadicType(T2) & (connectsType(T1, T2, R) | connectsType(T2, T1, R)))\n%         )\n% )).\n\n% fof(ax_powerType_must_have_instantiation, axiom, (\n%     ![PT]: (powerType(PT) => ?[T]: (instantiation(T, PT)))\n% )).";

export const baseRelationAxioms = "\n%%%%%%\n%%%%%% Relation axioms\n%%%%%%\n\n\n/**\n* Connection of types\n*\n* For every pair of types T1 and T2 and a relation type R,\n* If R is declared to connect T1 and T2 (connectsType(T1, T2, R)),\n* Then T1 and T2 must be valid types, and R must be a valid relation type.\n*/ \n% T1 is connected to T2 through R\nfof(ax_connection_of_types, axiom, (\n  ![T1, T2, RT]: (connectsType(T1, T2, RT) =>\n                      (monadicType(T1) & monadicType(T2) & relationType(RT))\n                  )\n)).\n\n/**\n* Connection of individuals\n*\n* For every pair of individuals X1 and X2, an relation type R, and a world W,\n* If X1 and X2 are connected through R in W (connects(X1, X2, R, W)),\n* Then X1 and X2 must be valid individuals, W must be a valid world,\n* and R must be a valid relation individual.\n*/\n\n% X1 is connected to X2 through R in a world W\n\n% Already introduced\n% fof(ax_connection_of_individuals, axiom, (\n%   ![X1, X2, R, W]: (connects(X1, X2, R, W) =>\n%                       (individual(X1) & individual(X2) & relationType(R) & world(W))\n%                   )\n% )).\n\n/**\n* Cardinality X..* to X..*\n*\n* Logic of connectsType and connectsIndividuals\n*\n* For every pair of types T1 and T2 and an relation type RT,\n* If RT is declared to connect T1 and T2 (connectsType(T1,T2,RT)),\n* Then there must exist:\n* - a world W,\n* - an individual X1 that is an instance of T1 in W,\n* - an individual X2 that is an instance of T2 in W,\n* - and an relation individual RI that is an instance of RT in W,\n* - such that X1 and X2 are connected through RI in W (connectsIndividuals(X1, X2, R, W)).\n*/\n% Every connection between types must have at least a world with a connection between individuals \n%     wich are instances of the types\nfof(ax_connects_in_types_and_instances_cardinality, axiom, (\n  ![T1, T2, RT]: (connectsType(T1, T2, RT) =>\n                      (?[W, X1, X2]: (iof(X1, T1, W) & iof(X2, T2, W) &\n                                            connects(X1, X2, RT, W) )\n                      )\n                  )\n)).\n\nfof(ax_connects_in_types_and_instances_2, axiom, (\n  ![T1, T2, RT]: (connectsType(T1, T2, RT) =>\n                      (![X1, X2, W]: (connects(X1, X2, RT, W) => (iof(X1, T1, W) & iof(X2, T2, W))))\n                  )\n                  \n)).\n\n\n\n\n%%%%%%\n%%%%%% Estereotypes \n%%%%%%\n\n% (47). mediation(U, UR) =def Universal(U) ∧ RelatorUniversal(UR) ∧ ∀x (x::U → ∃r r::UR ∧ m(r,x)) \n%\n% RT mediates a type T\nfof(ax_mediation_type_taxonomy, axiom, (\n  ![RT, T]: (mediatesType(RT, T) => (\n              relatorType(RT) & endurantType(T))\n            )\n)).\n\nfof(ax_mediation_type_definition, axiom, (\n  ![RT, T]: (mediatesType(RT, T) <=> (\n              relatorType(RT) & endurantType(T)  & ![X, W]: (iof(X, T, W) => ?[R, W]: (iof(R, RT, W) & mediates(R, X)))\n              )\n            )\n)).\n\n% verify /3 type relation\n% fof(ax_mediation_type_definition, axiom, (\n%   ![RT, T, RelationType]: (mediatesType(RT, T, RelationType) <=> (\n%               relatorType(RT) & endurantType(T)  & ![X, W]: (iof(X, T, W) => ?[R, W]: (iof(R, RT, W) & mediates(R, X) & connects(R, X, RelationType, W)))\n%               )\n%             )\n% )).\n\n\n% a mediation relation is reified as connecting R and T throught the mediation (Relation)\nfof(ax_mediation_has_a_relation_type, axiom, (\n  ![RelatorType, T]: (mediatesType(RelatorType, T) => ?[RelationType]: (connectsType(RelatorType, T, RelationType)))\n)).\n\n\nfof(ax_characterization_taxonomy, axiom, (\n  ![MT, ET]: (characterizes(MT,ET) => (endurantType(ET) & momentType(MT)))\n)).\n\nfof(ax_characterization_has_a_relation_type, axiom, (\n  ![MT, ET]: (characterizes(MT,ET) => ?[RelationType]: (connectsType(MT, ET, RelationType)))\n)).\n\n\n/*\n\n∀t iof(t, 1stOT) ↔ (∃y iof(y,t) ∧ (∀x iof(x,t) → iof(x,Individual)))\n∀t iof(t, 2ndOT) ↔ (∃y iof(y,t) ∧ (∀t1 iof(t1,t) → iof(t1,2ndOT)))\n∀t iof(t, 3rdOT) ↔ (∃y iof(y,t) ∧ (∀t1 iof(t1,t) → iof(t1,3rdOT)))\n\n\n*/\nfof(ax_instantiation_relation_has_a_relation_type, axiom, (\n  ![T1, T2]: (instantiation(T1,T2) => (monadicType(T1) & powerType(T2)))\n)).\n\nfof(ax_ufo_b_relation_has_a_relation_type, axiom, (\n  ![T1, T2]: (instantiation(T1,T2) => ?[RT]: (connectsType(T1, T2, RT)))\n)).\n\n\n\n/*\ncategorizes(t1, t2) ↔ Type(t1) ∧ ∀t3(t3 :: t1 → t3 < t2)26\n\nesse t3 :: t1 também é no nível de tipos? Se sim, então é outro instantiation\n\n% instantiation target is the powertype, so\nfof(ax_categorizes_definition, axiom, (\n    ![T1, T2]: (\n        categorizes(T1, T2) <=> (powerType(T2) & ![T3]:(instantiation(T3, T2) => properSpecializes(T3, T1)))\n    )\n)).\n*/\n\n\n\n%%%%%%\n%%%%%% UFO-B\n%%%%%%\nfof(ax_ufo_b_relation_has_a_relation_type, axiom, (\n  ![T1, T2]: (ufo_b_type(T1,T2) => ?[RT]: (connectsType(T1, T2, RT)))\n)).\n\n\n% TODO:: verificar necessidade do axioma abaixo se for incluir na formalização\n% \nfof(ax_manifestation_has_a_relation_type, axiom, (\n![ET, PT]: (manifestsType(ET, PT) => (endurantType(ET) & perdurantType(PT))\n          )\n)).\n\n% ---\n% fof(ax_manifestsInvolvedThings_a104, axiom, (\n%   ![E,P]: (manifests(E,P) => (endurant(E) & perdurant(P)))\n% )).\n \nfof(ax_manifestation_has_a_relation_type, axiom, (\n![T1, T2]: (manifestsType(T1,T2) => ?[RT]: (connectsType(T1, T2, RT)))\n)).\n\n\n%%%%%%\n%%%%%% Out of formalization\n%%%%%%\n\nfof(ax_material_has_a_relation_type, axiom, (\n![T1, T2]: (materialType(T1, T2) => ?[RT]: (connectsType(T1, T2, RT)))\n)).\n\n\nfof(ax_derivation_has_a_relation_type, axiom, (\n![T1, T2]: (derivationType(T1, T2) => ?[RT]: (connectsType(T1, T2, RT)))\n)).\n\n\nfof(ax_material_has_a_relation_type, axiom, (\n![T1, T2]: (comparativeType(T1, T2) => ?[RT]: (connectsType(T1, T2, RT)))\n)).";

export const ufoModules = "% Thing\n\nfof(ax_thing_taxonomy, axiom, (\n  ![X]: ((type_(X) | individual(X)) <=> (thing(X)))\n)).\n\nfof(ax_thing_partition, axiom, (\n  ~?[X]: (type_(X) & individual(X))\n)).\n\n% CHANGE:\n% Inclusion of monadicType and relationType\n% monadicType(X) only applies to individuals throught instantiation in a world\n% relationType(X)(X) only applies to connect individuals in a world\nfof(ax_type_taxonomy, axiom, (\n  ![X]: ((monadicType(X) | relationType(X)) <=> (type_(X)))\n)).\n\n% CHANGE:\n% nothing can be a monadicType an relation at the same time\nfof(ax_type_partition, axiom, (\n  ~?[X]: (monadicType(X) & relationType(X))\n)).\n\n\n% Individual\n\nfof(ax_individual_taxonomy, axiom, (\n  ![X]: ((concreteIndividual(X) | abstractIndividual(X)) <=> (individual(X)))\n)).\n\nfof(ax_individual_partition, axiom, (\n  ~?[X]: (concreteIndividual(X) & abstractIndividual(X))\n)).\n\n% Concrete Individual\n\nfof(ax_concreteIndividual_taxonomy, axiom, (\n  ![X]: ((endurant(X) | perdurant(X)) <=> (concreteIndividual(X)))\n)).\n\nfof(ax_concreteIndividual_partition, axiom, (\n  ~?[X]: (endurant(X) & perdurant(X))\n)).\n\n% Type\n\n% CHANGE:\n% type_ changed to monadicType\nfof(ax_type_taxonomy, axiom, (\n  ![X]: ((endurantType(X) | perdurantType(X)) => (monadicType(X)))\n)).\n\nfof(ax_type_partition, axiom, (\n  ~?[X]: (endurantType(X) & perdurantType(X))\n)).\n% Abstract Individual\n\nfof(ax_abstractIndividual_taxonomy_quale, axiom, (\n  ![X]: (quale(X) => (abstractIndividual(X)))\n)).\n\nfof(ax_abstractIndividual_taxonomy_set, axiom, (\n  ![X]: (set_(X) => (abstractIndividual(X)))\n)).\n\nfof(ax_abstractIndividual_taxonomy_world, axiom, (\n  ![X]: (world(X) => (abstractIndividual(X)))\n)).\n\nfof(ax_abstractIndividual_pairwiseDisjoint, axiom, (\n  ~?[X]: ((quale(X) & set_(X)) | (quale(X) & world(X)) | (set_(X) & world(X)))\n)).\n\n% Set\n\nfof(ax_set_taxonomy_qualityStructure, axiom, (\n  ![X]: (qualityStructure(X) => (set_(X)))\n)).\n\n% Quality Structure\n\nfof(ax_qualityStructure_taxonomy, axiom, (\n  ![X]: ((qualityDimension(X) | qualitySpace(X)) <=> (qualityStructure(X)))\n)).\n\nfof(ax_qualityStructure_partition, axiom, (\n  ~?[X]: (qualityDimension(X) & qualitySpace(X))\n)).\n% Endurant\n\nfof(ax_endurant_taxonomy, axiom, (\n  ![X]: ((substantial(X) | moment(X)) <=> (endurant(X)))\n)).\n\nfof(ax_endurant_partition, axiom, (\n  ~?[X]: (substantial(X) & moment(X))\n)).\n\n% Substantial\n\nfof(ax_substantial_taxonomy, axiom, (\n  ![X]: ((object(X) | collective(X) | quantity(X)) <=> (substantial(X)))\n)).\n\nfof(ax_substantial_partition, axiom, (\n  ~?[X]: ((object(X) & collective(X)) | (object(X) & quantity(X)) | (collective(X) & quantity(X)))\n)).\n\n% Moment\n\nfof(ax_moment_taxonomy, axiom, (\n  ![X]: ((intrinsicMoment(X) | relator(X)) <=> (moment(X)))\n)).\n\nfof(ax_moment_partition, axiom, (\n  ~?[X]: (intrinsicMoment(X) & relator(X))\n)).\n\n% Intrinsic Moment\n\nfof(ax_intrinsicMoment_taxonomy, axiom, (\n  ![X]: ((quality(X) | mode(X)) <=> (intrinsicMoment(X)))\n)).\n\nfof(ax_intrinsicMoment_partition, axiom, (\n  ~?[X]: (quality(X) & mode(X))\n)).\n\n% Mode\n\nfof(ax_mode_taxonomy_disposition, axiom, (\n  ![X]: (disposition(X) => (mode(X)))\n)).\n\nfof(ax_mode_taxonomy_externallyDependentMode, axiom, (\n  ![X]: (externallyDependentMode(X) => (mode(X)))\n)).\n\n% Externally Dependent Mode\n\nfof(ax_externallyDependentMode_taxonomy_quaIndividual, axiom, (\n  ![X]: (quaIndividual(X) => (externallyDependentMode(X)))\n)).\n% Endurant Type (by ontological nature)\n\nfof(ax_endurantType_taxonomy_nature, axiom, (\n  ![X]: ((substantialType(X) | momentType(X)) <=> (endurantType(X)))\n)).\n\nfof(ax_endurantType_partition_nature, axiom, (\n  ~?[X]: (substantialType(X) & momentType(X))\n)).\n\n% Substantial Type\n\nfof(ax_substantialType_taxonomy, axiom, (\n  ![X]: ((objectType(X) | collectiveType(X) | quantityType(X)) <=> (substantialType(X)))\n)).\n\nfof(ax_substantialType_partition, axiom, (\n  ~?[X]: ((objectType(X) & collectiveType(X)) | (objectType(X) & quantityType(X)) | (collectiveType(X) & quantityType(X)))\n)).\n\n% Moment Type\n\nfof(ax_momentType_taxonomy, axiom, (\n  ![X]: ((intrinsicMomentType(X) | relatorType(X)) <=> (momentType(X)))\n)).\n\nfof(ax_momentType_partition, axiom, (\n  ~?[X]: (intrinsicMomentType(X) & relatorType(X))\n)).\n\n% Intrinsic Moment Type\n\nfof(ax_intrinsicMomentType_taxonomy, axiom, (\n  ![X]: ((qualityType(X) | modeType(X)) <=> (intrinsicMomentType(X)))\n)).\n\nfof(ax_intrinsicMomentType_partition, axiom, (\n  ~?[X]: (qualityType(X) & modeType(X))\n)).\n% Endurant Type (by modal properties of types)\n\nfof(ax_endurantType_taxonomy_properties, axiom, (\n  ![X]: ((sortal(X) | nonSortal(X)) <=> (endurantType(X)))\n)).\n\nfof(ax_endurantType_partition_properties, axiom, (\n  ~?[X]: (sortal(X) & nonSortal(X))\n)).\n\n% Sortal\n\nfof(ax_sortal_taxonomy, axiom, (\n  ![X]: ((rigidSortal(X) | antiRigidSortal(X)) <=> (sortal(X)))\n)).\n\nfof(ax_sortal_partition, axiom, (\n  ~?[X]: (rigidSortal(X) & antiRigidSortal(X))\n)).\n\n% Rigid Sortal\n\nfof(ax_rigidSortal_taxonomy, axiom, (\n  ![X]: ((kind(X) | subkind(X)) <=> (rigidSortal(X)))\n)).\n\nfof(ax_rigidSortal_partition, axiom, (\n  ~?[X]: (kind(X) & subkind(X))\n)).\n\n% Anti-Rigid Sortal\n\nfof(ax_antiRigidSortal_taxonomy, axiom, (\n  ![X]: ((phase(X) | role(X)) <=> (antiRigidSortal(X)))\n)).\n\nfof(ax_antiRigidSortal_partition, axiom, (\n  ~?[X]: (phase(X) & role(X))\n)).\n\n% Non-Sortal\n\nfof(ax_nonSortal_taxonomy, axiom, (\n  ![X]: ((rigidNonSortal(X) | semiRigidNonSortal(X) | antiRigidNonSortal(X)) <=> (nonSortal(X)))\n)).\n\nfof(ax_nonSortal_partition, axiom, (\n  ~?[X]: ((rigidNonSortal(X) & semiRigidNonSortal(X)) | (rigidNonSortal(X) & antiRigidNonSortal(X)) | (semiRigidNonSortal(X) & antiRigidNonSortal(X)))\n)).\n\n% Category\n\nfof(ax_rigidNonSortal_taxonomy, axiom, (\n  ![X]: (rigidNonSortal(X) <=> (category(X)))\n)).\n\n% Mixin\n\nfof(ax_semiRigidNonSortal_taxonomy, axiom, (\n  ![X]: (semiRigidNonSortal(X) <=> (mixin(X)))\n)).\n\n% Anti-Rigid Non-Sortal\n\nfof(ax_antiRigidNonSortal_taxonomy, axiom, (\n  ![X]: ((phaseMixin(X) | roleMixin(X)) <=> (antiRigidNonSortal(X)))\n)).\n\nfof(ax_antiRigidNonSortal_partition, axiom, (\n  ~?[X]: (phaseMixin(X) & roleMixin(X))\n)).\n% CHANGE:\n% type_ changed to monadicType\nfof(ax_dIof, axiom, (\n  ![X,Y,W]: (iof(X,Y,W) => (monadicType(Y) & world(W)))\n)).\n\n% CHANGE:\n% type_ changed to monadicType\nfof(ax_dType, axiom, (\n  ![X]: (monadicType(X) <=> (?[Y,W]: iof(Y,X,W)))\n)).\n\n% CHANGE:\n% An individual can't instantiate another individual and can't connect individuals\nfof(ax_dIndividual, axiom, (\n  ![X]: (individual(X) <=> (~?[Y,W]: iof(Y,X,W) & ~?[Y,Z,W]: connects(Y,Z,X,W) ))\n)).\n\nfof(ax_multiLevel, axiom, (\n  ![X,Y,W]: (iof(X,Y,W) => (monadicType(X) | individual(X)))\n)).\n\nfof(ax_twoLevelConstrained, axiom, (\n  ~?[X,Y,Z,W]: (monadicType(X) & iof(X,Y,W) & iof(Y,Z,W))\n)).\n\n% CHANGE:\n% X and Y are connected trought R in a world W\n%\n% Addition of connects individuals taxonomy\nfof(ax_relationType_taxonomy, axiom, (\n  ![X,Y,R,W]: (connects(X,Y,R,W) => (relationType(R) & world(W) & concreteIndividual(X) & concreteIndividual(Y)))\n)).\n\n% CHANGE:\n% R can only be a relation if it connects 2 individuals\nfof(ax_relationType_must_connect_individuals, axiom, (\n  ![R]: (relationType(R) <=> ?[X,Y,W]:(connects(X,Y,R,W)))\n)).\n\nfof(ax_dSpecializes, axiom, (\n  ![X,Y]: (specializes(X,Y) => (type_(X) & type_(Y)))\n)).\n\n% CHANGE:\n% including how a specialization of a relation works\nfof(ax_specialization_a5, axiom, (\n  ![T1,T2]: (specializes(T1,T2) <=> (\n      (monadicType(T1) & monadicType(T2) & ![W]: (\n        world(W) => ![E]: (iof(E,T1,W) => iof(E,T2,W))\n        ))\n    |\n      (relationType(T1) & relationType(T2) & ![W]: (\n        world(W) => ![E1,E2]: (connects(E1,E2,T1,W) => connects(E1,E2,T2,W))\n        ))\n  ))\n)).\n\n\nfof(ax_properSpecializes_d1, axiom, (\n  ![X,Y]: (properSpecializes(X,Y) <=> (specializes(X,Y) & ~specializes(Y,X)))\n)).\n\n% CHANGE:\n% including that only monadicTypes can have sharedSpecialization\nfof(ax_sharedSpecializations_a6, axiom, (\n  ![T1,T2]: ( (monadicType(T1) & monadicType(T2)) => (![X,W]: (\n    (iof(X,T1,W) & iof(X,T2,W) & ~specializes(T1,T2) & ~specializes(T2,T1)) => (\n      (?[T3]: (specializes(T1,T3) & specializes(T2,T3) & iof(X,T3,W)))\n      | \n      (?[T3]: (specializes(T3,T1) & specializes(T3,T2) & iof(X,T3,W)))\n      )\n  )))\n)).\n% Rigidity\n\nfof(ax_dRigid_a18, axiom, (\n  ![T]: (rigid(T) <=> (endurantType(T) & (\n    ![X]: ((?[W1]: (world(W1) & iof(X,T,W1))) => (![W2]: (world(W2) => iof(X,T,W2))))\n  )))\n)).\n\nfof(ax_dAntiRigid_a19, axiom, (\n  ![T]: (antiRigid(T) <=> (endurantType(T) & (\n    ![X]: ((?[W1]: (world(W1) & iof(X,T,W1))) => (?[W2]: (world(W2) & ~iof(X,T,W2)))\n  ))))\n)).\n\nfof(ax_dSemiRigid_a20, axiom, (\n  ![T]: (semiRigid(T) <=> (endurantType(T) & ~rigid(T) & ~antiRigid(T)))\n)).\n\n% Sortality\n\nfof(ax_endurantsKind_a21, axiom, (\n  ![E]: (endurant(E) => (\n    ?[U]: (kind(U) & (![W]: (world(W) => iof(E,U,W))))\n  ))\n)).\n\nfof(ax_uniqueKind_a22, axiom, (\n  ![E,U,W]: ((world(W) & kind(U) & iof(E,U,W)) => (\n    ~?[U2,W2]: (kind(U2) & iof(E,U2,W2) & ~(U = U2))\n  ))\n)).\n\n% Changing \"ax_dSortal_a23\" from the form it was defined in the paper to \"sortals are endurant types that specialize some ultimate sortal\" seem to express the same concept while speeding up the execution of SPASS considerably\n\n% fof(ax_dSortal_a23, axiom, (\n%   ![S]: (sortal(S) <=> (endurantType(S) & (?[U]: (kind(U) & (![E,W]: (iof(E,S,W) => iof(E,U,W)))))))\n% )).\n\nfof(ax_dSortal_a23, axiom, (\n  ![S]: ((sortal(S)) <=> (endurantType(S) & (?[U]: (kind(U) & specializes(S,U)))))\n)).\n\n% Sortality + Rigidity\n\nfof(ax_rigidSortalsAreRigidAndSortal_xx, axiom, (\n  ![T]: ((rigidSortal(T)) <=> (rigid(T) & sortal(T)))\n)).\n\nfof(ax_antiRigidSortalsAreAntiRigidAndSortal_xx, axiom, (\n  ![T]: ((antiRigidSortal(T)) <=> (antiRigid(T) & sortal(T)))\n)).\n\nfof(ax_rigidNonSortalsAreRigidAndNonSortal_xx, axiom, (\n  ![T]: ((rigidNonSortal(T)) <=> (rigid(T) & nonSortal(T)))\n)).\n\nfof(ax_antiRigidNonSortalsAreAntiRigidAndNonSortal_xx, axiom, (\n  ![T]: ((antiRigidNonSortal(T)) <=> (antiRigid(T) & nonSortal(T)))\n)).\n\nfof(ax_semiRigidNonSortalsAreSemiRigidAndNonSortal_xx, axiom, (\n  ![T]: ((semiRigidNonSortal(T)) <=> (semiRigid(T) & nonSortal(T)))\n)).\n\n% Skipping (a29) because we leave the concept of semi-rigid sortals out of this ontology.\n% Defining the taxonomy of types of ontological natures through the categorization of the taxonomy of concrete individuals\n\nfof(ax_perdurantTypeDefinition_a44, axiom, (\n  ![T]: (perdurantType(T) <=> (\n    monadicType(T) & (![P,W]: ((world(W) & iof(P,T,W)) => (perdurant(P))))\n  ))\n)).\n\nfof(ax_endurantTypeDefinition_a44, axiom, (\n  ![T]: (endurantType(T) <=> (\n    monadicType(T) & (![E,W]: ((world(W) & iof(E,T,W)) => (endurant(E))))\n  ))\n)).\n\nfof(ax_substantialTypeDefinition_a44, axiom, (\n  ![T]: (substantialType(T) <=> (\n    monadicType(T) & (![E,W]: ((world(W) & iof(E,T,W)) => (substantial(E))))\n  ))\n)).\n\nfof(ax_momentTypeDefinition_a44, axiom, (\n  ![T]: (momentType(T) <=> (\n    monadicType(T) & (![E,W]: ((world(W) & iof(E,T,W)) => (moment(E))))\n  ))\n)).\n\nfof(ax_objectTypeDefinition_a44, axiom, (\n  ![T]: (objectType(T) <=> (\n    monadicType(T) & (![E,W]: ((world(W) & iof(E,T,W)) => (object(E))))\n  ))\n)).\n\nfof(ax_collectiveTypeDefinition_a44, axiom, (\n  ![T]: (collectiveType(T) <=> (\n    monadicType(T) & (![E,W]: ((world(W) & iof(E,T,W)) => (collective(E))))\n  ))\n)).\n\nfof(ax_quantityTypeDefinition_a44, axiom, (\n  ![T]: (quantityType(T) <=> (\n    monadicType(T) & (![E,W]: ((world(W) & iof(E,T,W)) => (quantity(E))))\n  ))\n)).\n\nfof(ax_intrinsicMomentTypeDefinition_a44, axiom, (\n  ![T]: (intrinsicMomentType(T) <=> (\n    monadicType(T) & (![E,W]: ((world(W) & iof(E,T,W)) => (intrinsicMoment(E))))\n  ))\n)).\n\nfof(ax_relatorTypeDefinition_a44, axiom, (\n  ![T]: (relatorType(T) <=> (\n    monadicType(T) & (![E,W]: ((world(W) & iof(E,T,W)) => (relator(E))))\n  ))\n)).\n\nfof(ax_qualityTypeDefinition_a44, axiom, (\n  ![T]: (qualityType(T) <=> (\n    monadicType(T) & (![E,W]: ((world(W) & iof(E,T,W)) => (quality(E))))\n  ))\n)).\n\nfof(ax_modeTypeDefinition_a44, axiom, (\n  ![T]: (modeType(T) <=> (\n    monadicType(T) & (![E,W]: ((world(W) & iof(E,T,W)) => (mode(E))))\n  ))\n)).\n% Ultimate Sortals Definitions (by ontological nature)\n\nfof(ax_objectKindDefinition_a45, axiom, (\n  ![T]: (objectKind(T) <=> (objectType(T) & kind(T)))\n)).\n\nfof(ax_collectiveKindDefinition_a45, axiom, (\n  ![T]: (collectiveKind(T) <=> (collectiveType(T) & kind(T)))\n)).\n\nfof(ax_quantityKindDefinition_a45, axiom, (\n  ![T]: (quantityKind(T) <=> (quantityType(T) & kind(T)))\n)).\n\nfof(ax_modeKindDefinition_a45, axiom, (\n  ![T]: (modeKind(T) <=> (modeType(T) & kind(T)))\n)).\n\nfof(ax_qualityKindDefinition_a45, axiom, (\n  ![T]: (qualityKind(T) <=> (qualityType(T) & kind(T)))\n)).\n\nfof(ax_relatorKindDefinition_a45, axiom, (\n  ![T]: (relatorKind(T) <=> (relatorType(T) & kind(T)))\n)).\n\n% Skipping (t22) because (a21) makes it trivial\n% TODO: review whether it is necessary to reduce mereology to concrete individuals; I am leaving this axiom out for the moment\n\n% fof(ax_partArguments, axiom, (\n%   ![X,Y]: (part(X,Y) => (concreteIndividual(X) & concreteIndividual(Y)))\n% )).\n\nfof(ax_reflexiveParthood, axiom, (\n  ![X]: (partOf(X,X))\n)).\n\nfof(ax_antiSymmetricParthood_a47, axiom, (\n  ![X,Y]: ((partOf(X,Y) & partOf(Y,X)) => (X=Y))\n)).\n\nfof(ax_antiSymmetricParthood_a48, axiom, (\n  ![X,Y]: ((partOf(X,Y) & partOf(Y,X)) => (X=Y))\n)).\n\nfof(ax_transitiveParthood_a49, axiom, (\n  ![X,Y,Z]: ((partOf(X,Y) & partOf(Y,Z)) => (partOf(X,Z)))\n)).\n\nfof(ax_overlappingWholes_a50, axiom, (\n  ![X,Y]: ((overlap(X,Y)) <=> (?[Z]: (partOf(Z,X) & partOf(Z,Y))))\n)).\n\nfof(ax_strongSupplementation_a51, axiom, (\n  ![X,Y]: (~partOf(X,Y) <=> ?[Z]: (partOf(Z,X) & ~overlap(Z,Y)))\n)).\n\nfof(ax_properPart_a52, axiom, (\n  ![X,Y]: (properPartOf(X,Y) <=> (partOf(X,Y) & ~partOf(Y,X)))\n)).\n\nfof(ax_binarySum_a53, axiom, (\n  ![X,Y,Z]: (sum(Z,X,Y) <=> ![W]: (overlap(W,Z) <=> (overlap(W,X) | overlap(W,Y))))\n)).\nfof(ax_function, axiom,  (\n  ![X,Y]: (functionsAs(X,Y) => (endurant(X) & monadicType(Y)))\n)).\n\nfof(ax_genericFunctionalDependence_a55, axiom, (\n  ![T1,T2,W]: (gfd(T1,T2,W) <=> \n    ![E1]: ((iof(T1,E1,W) & functionsAs(T1,E1)) => ?[E2]: (~(E1=E2) & iof(T2,E2,W) & functionsAs(T2,E2))))\n)).\n\nfof(ax_individualFunctionalDependence_a56, axiom, (\n  ![E1,T1,E2,T2,W]: (ifd(E1,T1,E2,T2,W) <=> (\n    gfd(T1,T2,W) & iof(E1,T1,W) & iof(E2,T2,W) & (functionsAs(E1,T1) => functionsAs(E2,T2))\n  ))\n)).\n\nfof(ax_componentOf_a57, axiom, (\n  ![E1,T1,E2,T2,W]: (componentOf(E1,T1,E2,T2,W) <=> (properPartOf(E1,E2) & ifd(E1,T1,E2,T2,W)))\n)).\nfof(ax_constitutedByInvolvedNatures_a58, axiom, (\n  ![X,Y,W]: (constitutedBy(X,Y,W) => ((endurant(X) <=> endurant(Y)) & (perdurant(X) <=> perdurant(Y)) & world(W)))\n)).\n\nfof(ax_constitutedByDifferentKinds_a59, axiom, (\n  ![E1,E2,T1,T2,W]: ((constitutedBy(E1,E2,W) & iof(E1,T1,W) & iof(E2,T2,W) & kind(T1) & kind(T2)) => (~(T1=T2)))\n)).\n\nfof(ax_genericConstitutionalDependence_a60, axiom, (\n  ![T1,T2]: (genericConstitutionalDependence(T1,T2) <=> (\n    monadicType(T1) & monadicType(T2) & ![E1,W]: (iof(E1,T1,W) => (\n      ?[E2]: (constitutedBy(E1,E2,W) & iof(E2,T2,W)\n    )))\n  ))\n)).\n\nfof(ax_constitution_a61, axiom, (\n  ![E1,T1,E2,T2,W]: (constitution(E1,T1,E2,T2,W) <=> (\n    iof(E1,T1,W) & iof(E2,T2,W) & genericConstitutionalDependence(T1,T2) & constitutedBy(E1,E2,W)\n  ))\n)).\n\nfof(ax_wheneverAConstitutedPerdurantExistsTheConstitutedByRelationHolds_a62, axiom, (\n  ![P1,P2,W1]: ((constitutedBy(P1,P2,W1) & perdurant(P1)) => (![W2]: (exists(P1,W2) => constitutedBy(P1,P2,W2))))\n)).\n\nfof(ax_constitutedByIsAsymmetric_a63, axiom, (\n  ![E1,E2,W]: (constitutedBy(E1,E2,W) => ~constitutedBy(E2,E1,W))\n)).\nfof(ax_exists_a64, axiom, (\n  ![X,W]: (exists(X,W) => (thing(X) & world(W)))\n)).\n\nfof(ax_existentiallyDependsOn_a65, axiom, (\n  ![X,Y]: (existentiallyDependsOn(X,Y) <=> (![W]: (exists(X,W) => exists(Y,W))))\n)).\n\nfof(ax_existentiallyIndependentOf_a66, axiom, (\n  ![X,Y]: (existentiallyIndependentOf(X,Y) <=> (~existentiallyDependsOn(X,Y) & ~existentiallyDependsOn(Y,X)))\n)).\n\n% TODO: introduce transitivity and anti-symmetry of existential dependence\n% TODO: introduce continuity of existence with perdurants never ceasing to exist\n%  Inherence\n\nfof(ax_inherenceImpliesExistentialDependence_a67, axiom, (\n  ![M,X]: (inheresIn(M,X) => existentiallyDependsOn(M,X))\n)).\n\nfof(ax_thingsInvolvedInInherence_a68, axiom, (\n  ![M,X]: (inheresIn(M,X) => (moment(M) & (monadicType(X) | endurant(X))))\n)).\n\n% TODO: add definition (d5) for the \"bearer\" axiom\n\nfof(ax_irreflexiveInherence, axiom, (\n  ![X]: (~inheresIn(X,X))\n)).\n\nfof(ax_asymmetricInherence, axiom, (\n  ![X,Y]: (inheresIn(X,Y) => ~inheresIn(Y,X))\n)).\n\nfof(ax_intransitiveInherence, axiom, (\n  ![X,Y,Z]: ((inheresIn(X,Y) & inheresIn(Y,Z)) => ~inheresIn(X,Z))\n)).\n\nfof(ax_uniqueInherence_a69, axiom, (\n  ![X,Y,Z]: ((inheresIn(X,Y) & inheresIn(X,Z)) => (Y=Z))\n)).\n\n% Moments\n\nfof(ax_dMomentOf_d6, axiom, (\n  ![M,X]: (momentOf(M,X) <=> (inheresIn(M,X) | (\n    ?[M2]: (inheresIn(M,M2) & momentOf(M2,X))\n  )))\n)).\n\nfof(ax_dUltimateBearerOf_d7, axiom, (\n  ![B,M]: (ultimateBearerOf(B,M) <=> (~moment(B) & momentOf(M,B)))\n)).\n\nfof(ax_everyMomentHasUniqueAUltimateBearer_a70, axiom, (\n  ![M]: (moment(M) => (?[B]: (ultimateBearerOf(B,M) & (\n    ![B2]: (ultimateBearerOf(B2,M) <=> (B=B2))\n  ))))\n)).\n\nfof(ax_noMomentOfCycles, axiom, (\n  ~?[M]: momentOf(M,M)\n)).\n% External Dependence and Externally Dependent Modes\n\nfof(ax_externallyDependsOn_a71, axiom, (\n  ~?[M,X]: (externallyDependsOn(M,X) <=> (existentiallyDependsOn(M,X) & (![Y]: (inheresIn(M,Y) => existentiallyIndependentOf(X,Y)))))\n)).\n\n% CHANGED:\n% removed to simplify the formalization\n% fof(ax_dExternallyDependentMode_a72, axiom, (\n%   ![M]: (externallyDependentMode(M) <=> (mode(M) & (?[X]: (externallyDependsOn(M,X)))))\n% )).\n\n% Founded by\n% CHANGED:\n% removed to simplify the formalization\n% fof(ax_foundedByInvolvedThings_a73, axiom, (\n%   ![M,P]: (foundedBy(M,P) <=> ((externallyDependentMode(M) | relator(M)) & perdurant(P)))\n% )).\n\n% CHANGED:\n% removed to simplify the formalization\n% fof(ax_relationalModesHaveAFoundationEvent_a74, axiom, (\n%   ![M]: ((externallyDependentMode(M) | relator(M)) => (?[P]: (foundedBy(M,P))))\n% )).\n\n% CHANGED:\n% removed to simplify the formalization\n% fof(ax_uniqueFoundationEvents_a74, axiom, (\n%   ![M,P1,P2]: ((foundedBy(M,P1) & foundedBy(M,P2)) => (P1=P2))\n% )).\n\n% Qua Individual\n\n% CHANGED:\n% removed to simplify the formalization\n% fof(ax_dQuaIndividualOf_a75, axiom, (\n%   ![X,Y]: (quaIndividualOf(X,Y) <=> (![Z]: (overlap(Z,X) <=> (\n%     ?[X1, X2]: ((externallyDependsOn(Z,X1) & foundedBy(Z,X2)) & inheresIn(Z,Y) & (![P]: (foundedBy(X,P) => foundedBy(Z,P)))\n%   )))))\n% )).\n\n% CHANGED:\n% removed to simplify the formalization\n% fof(ax_dQuaIndividual_a76, axiom, (\n%   ![X]: (quaIndividual(X) <=> ?[Y]: (quaIndividualOf(X,Y)))\n% )).\n\n% Qua Individual is already defined as a subtype of Externally Dependent Mode in the taxonomy; skipping (a78)\n\n% Skipping (a79); already defined in (a74)\n\n% CHANGED:\n% removed to simplify the formalization\n% fof(ax_thePartsOfARelatorShareTheFoundationOfTheWhole_a80, axiom, (\n%   ![X,Y,Z]: ((relator(X) & partOf(Z,X)) => (![P]: (foundedBy(Z,P) => foundedBy(X,P))))\n% )).\n\n% CHANGE:\n% removed to simplify the formalization. It is generating conflicts when defining relatorKind(X)\n% fof(ax_dRelator_a81, axiom, (\n%   ![R]: (relator(R) <=> (\n%     (?[X]: (properPartOf(X,R))\n%     & (![Y,Z]: ((properPartOf(Y,R) & properPartOf(Z,R)) => (quaIndividual(Y) & quaIndividual(Z) & existentiallyDependsOn(Y,Z) & existentiallyDependsOn(Z,Y) & (![P]: (foundedBy(Y,P) <=> foundedBy(Z,P))))))\n%     & (![Y2,Z2]: ((properPartOf(Y2,R) & quaIndividual(Z2) & existentiallyDependsOn(Y2,Z2) & existentiallyDependsOn(Z2,Y2) & (![P2]: (foundedBy(Y2,P2) <=> foundedBy(Z2,P2)))) => (properPartOf(Z2,R))))\n%   )))\n% )).\n\n% CHANGE:\n% not necessary a quaIndividualOf and only the taxonomy of the involved things\nfof(ax_dMediates_a82, axiom, (\n  ![R,E]: (mediates(R,E) => (relator(R) & endurant(E)))\n)).\n\nfof(ax_relator_has_mediates, axiom, (\n  ![R]: (relator(R) => ?[E1,E2]:(E1!=E2 & E1!=R & E2!=R & endurant(E1) & endurant(E2) & mediates(R, E1) & mediates(R, E2)))\n)).\n\n%%%%%%%%%%%%%%%%%%%% Characterization %%%%%%%%%%%%%%%%%%%%\n\n% CHANGE:\n% momentType(M) to momentType(MT)\nfof(ax_endurantTypeCharacterizationByMomentTypes_a83, axiom, (\n  ![ET,MT]: (characterizes(MT,ET) => (\n    endurantType(ET)\n    & momentType(MT)\n    & (![E,W]: (iof(E,ET,W) => (?[M]: (iof(M,MT,W) & inheresIn(M,E)))))\n    & (![M2,W2]: (iof(M2,MT,W2) => (?[E2]: (iof(E2,ET,W2) & inheresIn(M2,E2)))))\n  ))\n)).\n%%%%%%%%%%%% Qualities and Quality Structures %%%%%%%%%%%%\n\n% Skipping (a85); previously introduced in the taxonomy\n% Skipping (a86); previously introduced in the taxonomy\n% Skipping (a87); previously introduced in the taxonomy\n\n% Quality Structures\n\nfof(ax_dQualityStructure_d10, axiom, (\n  ![QS]: (qualityStructure(QS) <=> (?[QT]: (qualityType(QT) & associatedWith(QS,QT))))\n)).\n\nfof(ax_dQualityStructure_d10, axiom, (\n  ![QS]: (qualityStructure(QS) <=> (?[QT]: (qualityType(QT) & associatedWith(QS,QT))))\n)).\n%%%%%%%%%%%%%%%% Endurants and Perdurants %%%%%%%%%%%%%%%%\n\nfof(ax_manifestsInvolvedThings_a104, axiom, (\n  ![E,P]: (manifests(E,P) => (endurant(E) & perdurant(P)))\n)).\n\nfof(ax_lifeOfInvolvedThings_a105, axiom, (\n  ![E,P]: (lifeOf(P,E) => (\n    endurant(E)\n    & (![P2]: (overlap(P2,P) <=> (perdurant(P2) & manifests(E,P2))))\n  ))\n)).\n\n% TODO: review ax_lifeOfInvolvedThings_a105 and its translation of the small sigma predicate schema in (a105)\n\nfof(ax_meetsInvolvedThings_a106, axiom, (\n  ![P1,P2]: (meets(P1,P2) => (perdurant(P1) & perdurant(P2)))\n)).\n";
